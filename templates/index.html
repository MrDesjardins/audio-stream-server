<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouTube Radio</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="stylesheet" href="/static/style.css?v=1737847300">
</head>

<body>
    <div class="container">
        <header>
            <button class="theme-toggle" onclick="toggleTheme()" aria-label="Toggle theme">
                <i class="fas fa-moon" id="theme-icon"></i>
            </button>
            <h1><i class="fab fa-youtube"></i> Private YouTube Radio</h1>
        </header>

        <main>
            <div class="control-section">
                <div class="input-group">
                    <label for="youtube_video_id">
                        <i class="fas fa-link"></i> Add to Queue - YouTube Video ID or URL
                    </label>
                    <input type="text" id="youtube_video_id" placeholder="Enter YouTube ID or URL" value="">
                </div>

                {% if transcription_enabled %}
                <div class="checkbox-group">
                    <label for="skip_transcription" class="checkbox-label">
                        <input type="checkbox" id="skip_transcription" name="skip_transcription">
                        <span>
                            <i class="fas fa-music"></i>
                            Skip transcription (for music)
                        </span>
                    </label>
                </div>
                {% endif %}

                <div class="button-group">
                    <button onclick="addToQueue()" class="btn btn-primary">
                        <i class="fas fa-plus-circle"></i>
                        Add to Queue
                    </button>
                    <button onclick="clearQueue()" class="btn btn-secondary">
                        <i class="fas fa-trash-alt"></i>
                        Clear Queue
                    </button>
                </div>
            </div>

            <div class="queue-section">
                <div class="queue-header">
                    <h2>
                        <i class="fas fa-list"></i>
                        Queue
                    </h2>
                    <span id="queue-count" class="queue-count">0 tracks</span>
                </div>
                <div id="queue-list" class="queue-list">
                    <p class="queue-empty">Queue is empty. Add videos above to start!</p>
                </div>
                <div class="queue-controls">
                    <button onclick="playQueue()" class="btn btn-play-queue">
                        <i class="fas fa-play"></i>
                        <span>Play Queue</span>
                    </button>
                </div>
            </div>

            <div class="player-section">
                <div class="status-indicator">
                    <span id="status-dot" class="status-dot"></span>
                    <i class="fas fa-broadcast-tower"></i>
                    <p id="status">Status: idle</p>
                </div>

                <!-- Stream URL: http://{{ host }}:{{ api_port }}/mystream -->
                <!-- If you see 127.0.0.1 above, check your .env file FASTAPI_HOST setting -->
                <audio id="player" controls playsinline preload="auto">
                    <source src="http://{{ host }}:{{ api_port }}/mystream" type="audio/mpeg">
                    Your browser does not support audio.
                </audio>
                <div id="stream-status" class="stream-status hidden">
                    <i class="fas fa-sync fa-spin"></i>
                    <span id="stream-status-text">Reconnecting...</span>
                </div>

                <div class="playback-controls">
                    <button onclick="rewind()" class="btn btn-control">
                        <i class="fas fa-backward"></i>
                        <span class="btn-label">-15s</span>
                    </button>
                    <button onclick="pauseAudio()" class="btn btn-control">
                        <i class="fas fa-pause"></i>
                        <span class="btn-label">Pause</span>
                    </button>
                    <button onclick="playAudio()" class="btn btn-control">
                        <i class="fas fa-play"></i>
                        <span class="btn-label">Play</span>
                    </button>
                    <button onclick="fastforward()" class="btn btn-control">
                        <i class="fas fa-forward"></i>
                        <span class="btn-label">+15s</span>
                    </button>
                    <button onclick="playNext()" class="btn btn-control btn-next">
                        <i class="fas fa-step-forward"></i>
                        <span class="btn-label">Next</span>
                    </button>
                    <button onclick="stopStream()" class="btn btn-control btn-stop">
                        <i class="fas fa-stop"></i>
                        <span class="btn-label">Stop</span>
                    </button>
                </div>

                <div class="speed-controls">
                    <span class="speed-label">Speed:</span>
                    <button onclick="setSpeed(1.0)" class="btn btn-speed active" id="speed-1x">
                        <span class="btn-label">1x</span>
                    </button>
                    <button onclick="setSpeed(1.2)" class="btn btn-speed" id="speed-1.2x">
                        <span class="btn-label">1.2x</span>
                    </button>
                    <button onclick="setSpeed(1.5)" class="btn btn-speed" id="speed-1.5x">
                        <span class="btn-label">1.5x</span>
                    </button>
                    <button onclick="setSpeed(2.0)" class="btn btn-speed" id="speed-2x">
                        <span class="btn-label">2x</span>
                    </button>
                </div>
            </div>

            {% if transcription_enabled %}
            <div class="transcription-section">
                <div class="transcription-header">
                    <h2>
                        <i class="fas fa-file-alt"></i>
                        Transcription
                    </h2>
                </div>
                <div id="transcription-status" class="transcription-status">
                    <p class="transcription-idle">Start streaming to see transcription status</p>
                </div>
            </div>

            <!-- Summary Modal -->
            <div id="summary-modal" class="modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h2><i class="fas fa-file-alt"></i> Summary</h2>
                        <button onclick="closeSummaryModal()" class="modal-close">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div id="summary-content" class="modal-body">
                        <p>Loading summary...</p>
                    </div>
                </div>
            </div>
            {% endif %}

            <div class="history-section">
                <div class="history-header">
                    <h2>
                        <i class="fas fa-history"></i>
                        Recent Videos
                    </h2>
                </div>
                <div id="history-list" class="history-list">
                    <p class="history-empty">No history yet</p>
                </div>
            </div>
        </main>
    </div>

    <script>
        const player = document.getElementById('player');
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status');
        const streamStatus = document.getElementById('stream-status');
        const streamStatusText = document.getElementById('stream-status-text');
        const MAX_HISTORY_ITEMS = 10;
        const transcriptionEnabled = {{ 'true' if transcription_enabled else 'false' }};
        let currentVideoId = null;
        let currentQueueId = null;
        let isPlaying = false;
        let currentTrackTitle = null;
        const defaultTitle = 'YouTube Radio';

        // Stream resilience configuration
        let retryCount = 0;
        let maxRetries = 10;
        let retryDelay = 1000; // Start with 1 second
        let maxRetryDelay = 30000; // Max 30 seconds between retries
        let retryTimeout = null;
        let lastPlayPosition = 0;
        let isRetrying = false;
        let stalledTimeout = null;

        // Theme Management
        function getSystemTheme() {
            return window.matchMedia('(prefers-color-scheme: light)').matches ? 'light' : 'dark';
        }

        function initTheme() {
            const savedTheme = localStorage.getItem('theme');
            const themeIcon = document.getElementById('theme-icon');

            if (savedTheme) {
                document.documentElement.setAttribute('data-theme', savedTheme);
                updateThemeIcon(savedTheme);
            } else {
                const systemTheme = getSystemTheme();
                updateThemeIcon(systemTheme);
            }
        }

        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const systemTheme = getSystemTheme();
            let newTheme;

            if (!currentTheme) {
                // First toggle: switch from system default to opposite
                newTheme = systemTheme === 'light' ? 'dark' : 'light';
            } else if (currentTheme === systemTheme) {
                // Currently matching system, switch to opposite
                newTheme = systemTheme === 'light' ? 'dark' : 'light';
            } else {
                // Currently opposite of system, go back to system (remove override)
                document.documentElement.removeAttribute('data-theme');
                localStorage.removeItem('theme');
                updateThemeIcon(systemTheme);
                return;
            }

            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            updateThemeIcon(newTheme);
        }

        function updateThemeIcon(theme) {
            const themeIcon = document.getElementById('theme-icon');
            if (theme === 'light') {
                themeIcon.className = 'fas fa-moon';
            } else {
                themeIcon.className = 'fas fa-sun';
            }
        }

        // Listen for system theme changes
        window.matchMedia('(prefers-color-scheme: light)').addEventListener('change', (e) => {
            const savedTheme = localStorage.getItem('theme');
            if (!savedTheme) {
                updateThemeIcon(e.matches ? 'light' : 'dark');
            }
        });

        // Initialize theme on page load
        initTheme();

        // Stream Resilience Functions
        function showStreamStatus(message) {
            streamStatusText.textContent = message;
            streamStatus.classList.remove('hidden');
        }

        function hideStreamStatus() {
            streamStatus.classList.add('hidden');
        }

        function retryStream() {
            if (retryCount >= maxRetries) {
                console.error(`Max retries (${maxRetries}) reached. Please refresh the page or restart the stream.`);
                updateStatus(`Stream failed after ${maxRetries} attempts. Please try again.`, 'error');
                hideStreamStatus();
                isRetrying = false;
                return;
            }

            retryCount++;
            const currentDelay = Math.min(retryDelay * Math.pow(1.5, retryCount - 1), maxRetryDelay);

            console.log(`Retry attempt ${retryCount}/${maxRetries} in ${currentDelay}ms...`);
            showStreamStatus(`Reconnecting (attempt ${retryCount}/${maxRetries})...`);

            isRetrying = true;

            retryTimeout = setTimeout(() => {
                try {
                    // Save current position
                    if (!isNaN(player.currentTime) && player.currentTime > 0) {
                        lastPlayPosition = player.currentTime;
                    }

                    // Reload the stream
                    const streamUrl = 'http://{{ host }}:{{ api_port }}/mystream?t=' + Date.now();
                    player.src = streamUrl;
                    player.load();

                    // Try to restore position
                    if (lastPlayPosition > 0) {
                        player.currentTime = lastPlayPosition;
                    }

                    // Attempt to play
                    player.play().then(() => {
                        console.log('Stream reconnected successfully');
                        retryCount = 0; // Reset retry count on success
                        hideStreamStatus();
                        isRetrying = false;
                    }).catch(err => {
                        console.error('Failed to play after reload:', err);
                        retryStream(); // Try again
                    });
                } catch (err) {
                    console.error('Error during stream retry:', err);
                    retryStream(); // Try again
                }
            }, currentDelay);
        }

        function cancelRetry() {
            if (retryTimeout) {
                clearTimeout(retryTimeout);
                retryTimeout = null;
            }
            if (stalledTimeout) {
                clearTimeout(stalledTimeout);
                stalledTimeout = null;
            }
            retryCount = 0;
            isRetrying = false;
            hideStreamStatus();
        }

        // Audio Player Event Handlers for Resilience
        player.addEventListener('error', function(e) {
            console.error('Audio player error:', e);
            const error = player.error;
            if (error) {
                console.error(`Error code: ${error.code}, message: ${error.message}`);

                // Only retry if we're supposed to be playing
                if (isPlaying && !isRetrying) {
                    console.log('Stream error detected, attempting to reconnect...');
                    retryStream();
                }
            }
        });

        player.addEventListener('stalled', function() {
            console.warn('Stream stalled, buffering...');
            showStreamStatus('Buffering...');

            // Clear any existing stalled timeout
            if (stalledTimeout) {
                clearTimeout(stalledTimeout);
            }

            // If still stalled after 10 seconds, try to reconnect
            stalledTimeout = setTimeout(() => {
                if (isPlaying && !isRetrying) {
                    console.log('Stream stalled for too long, attempting to reconnect...');
                    retryStream();
                }
            }, 10000);
        });

        player.addEventListener('waiting', function() {
            console.log('Waiting for data...');
            showStreamStatus('Buffering...');
        });

        player.addEventListener('canplay', function() {
            console.log('Can play - enough data loaded');
            if (!isRetrying) {
                hideStreamStatus();
            }

            // Clear stalled timeout if stream is playable
            if (stalledTimeout) {
                clearTimeout(stalledTimeout);
                stalledTimeout = null;
            }
        });

        player.addEventListener('playing', function() {
            console.log('Playback started/resumed');
            hideStreamStatus();
            retryCount = 0; // Reset retry count when successfully playing

            // Clear stalled timeout
            if (stalledTimeout) {
                clearTimeout(stalledTimeout);
                stalledTimeout = null;
            }
        });

        player.addEventListener('pause', function() {
            console.log('Playback paused');
            // Don't show reconnection UI if user paused manually
            if (!isRetrying) {
                hideStreamStatus();
            }
        });

        player.addEventListener('loadstart', function() {
            console.log('Started loading stream');
        });

        player.addEventListener('progress', function() {
            // Stream is downloading, this is good
            if (stalledTimeout) {
                clearTimeout(stalledTimeout);
                stalledTimeout = null;
            }
        });

        player.addEventListener('suspend', function() {
            // Browser has suspended loading (might be due to buffering enough data)
            console.log('Stream loading suspended (browser buffered enough)');
        });

        player.addEventListener('abort', function() {
            console.warn('Stream loading aborted');
        });

        // Update browser window title
        function updateWindowTitle(title) {
            if (title) {
                document.title = `${title} - YouTube Radio`;
                currentTrackTitle = title;
            } else {
                document.title = defaultTitle;
                currentTrackTitle = null;
            }
        }

        // Set up MediaSession for lock screen and car display controls
        function setupMediaSession(trackInfo) {
            if (!('mediaSession' in navigator)) {
                return;
            }

            // Set metadata if available
            if (trackInfo && trackInfo.thumbnail_url) {
                navigator.mediaSession.metadata = new MediaMetadata({
                    title: trackInfo.title,
                    artist: trackInfo.channel || 'YouTube',
                    album: 'YouTube Radio',
                    artwork: [
                        { src: trackInfo.thumbnail_url, sizes: '512x512', type: 'image/jpeg' },
                        { src: trackInfo.thumbnail_url, sizes: '256x256', type: 'image/jpeg' },
                        { src: trackInfo.thumbnail_url, sizes: '128x128', type: 'image/jpeg' }
                    ]
                });
            }

            // Set up action handlers for background playback
            navigator.mediaSession.setActionHandler('play', () => {
                player.play();
            });
            navigator.mediaSession.setActionHandler('pause', () => {
                player.pause();
            });
            navigator.mediaSession.setActionHandler('nexttrack', () => {
                playNext();
            });
            navigator.mediaSession.setActionHandler('previoustrack', () => {
                rewind();
            });
            navigator.mediaSession.setActionHandler('seekbackward', (details) => {
                player.currentTime = Math.max(0, player.currentTime - (details.seekOffset || 15));
            });
            navigator.mediaSession.setActionHandler('seekforward', (details) => {
                player.currentTime = Math.max(0, player.currentTime + (details.seekOffset || 15));
            });
        }

        // Queue Management
        async function fetchQueue() {
            try {
                const res = await fetch('/queue');
                const data = await res.json();
                return data.queue || [];
            } catch (e) {
                console.error('Error fetching queue:', e);
                return [];
            }
        }

        async function addToQueue() {
            const input = document.getElementById('youtube_video_id').value;

            if (!input.trim()) {
                updateStatus('Please enter a YouTube ID or URL', 'error');
                return;
            }

            const youtube_video_id = extractVideoId(input);

            if (!youtube_video_id) {
                updateStatus('Invalid YouTube ID or URL', 'error');
                return;
            }

            const skipTranscriptionCheckbox = document.getElementById('skip_transcription');
            const skip_transcription = skipTranscriptionCheckbox ? skipTranscriptionCheckbox.checked : false;

            try {
                updateStatus('Adding to queue...', 'streaming');

                const res = await fetch('/queue/add', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ youtube_video_id, skip_transcription })
                });
                const data = await res.json();

                if (res.ok) {
                    updateStatus('Added to queue: ' + data.title, 'streaming');
                    document.getElementById('youtube_video_id').value = '';
                    await renderQueue();
                } else {
                    updateStatus('Failed to add to queue', 'error');
                }
            } catch (error) {
                updateStatus('Failed to add to queue', 'error');
                console.error(error);
            }
        }

        async function clearQueue() {
            if (!confirm('Clear all items from queue?')) {
                return;
            }

            try {
                await fetch('/queue/clear', { method: 'POST' });
                await renderQueue();
                updateStatus('Queue cleared', 'idle');
            } catch (e) {
                console.error('Error clearing queue:', e);
            }
        }

        async function removeFromQueue(queueId) {
            try {
                await fetch(`/queue/${queueId}`, { method: 'DELETE' });
                await renderQueue();
            } catch (e) {
                console.error('Error removing from queue:', e);
            }
        }

        async function playQueue() {
            const queue = await fetchQueue();

            if (queue.length === 0) {
                updateStatus('Queue is empty', 'error');
                return;
            }

            // Start streaming the first item
            const firstItem = queue[0];
            await startStreamFromQueue(firstItem.youtube_id, firstItem.id);
        }

        async function playNext() {
            try {
                const res = await fetch('/queue/next', { method: 'POST' });
                const data = await res.json();

                if (data.status === 'queue_empty') {
                    updateStatus('Queue is empty', 'idle');
                    player.pause();
                    isPlaying = false;
                    cancelRetry(); // Stop any retry attempts
                    updateWindowTitle(null);  // Reset title when queue is empty
                    await renderQueue();
                    return;
                }

                if (data.status === 'next') {
                    await startStreamFromQueue(data.youtube_id, data.queue_id);
                    await renderQueue();
                }
            } catch (error) {
                console.error('Error playing next:', error);
                updateStatus('Failed to play next', 'error');
            }
        }

        async function startStreamFromQueue(youtube_video_id, queue_id) {
            const skipTranscriptionCheckbox = document.getElementById('skip_transcription');
            const skip_transcription = skipTranscriptionCheckbox ? skipTranscriptionCheckbox.checked : false;

            try {
                const res = await fetch('/stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ youtube_video_id, skip_transcription })
                });
                const data = await res.json();
                updateStatus(data.status || data.detail, res.ok ? 'streaming' : 'error');

                if (res.ok) {
                    currentVideoId = youtube_video_id;
                    currentQueueId = queue_id;
                    isPlaying = true;
                    cancelRetry(); // Cancel any ongoing retries

                    // Update browser window title with track name
                    const queue = await fetchQueue();
                    const currentItem = queue.find(item => item.id === queue_id);
                    if (currentItem) {
                        updateWindowTitle(currentItem.title);
                        setupMediaSession(currentItem);
                    }

                    // Update history
                    await renderHistory();
                    await renderQueue();

                    // Setup transcription tracking if enabled
                    if (transcriptionEnabled && !skip_transcription) {
                        currentVideoId = youtube_video_id;
                    }

                    // Reload audio with cache-busting
                    const streamUrl = 'http://{{ host }}:{{ api_port }}/mystream?t=' + Date.now();
                    player.src = streamUrl;
                    player.load();
                    player.play().catch(e => {
                        console.error('Audio playback failed:', e);
                        // Auto-retry if initial play fails
                        if (isPlaying) {
                            retryStream();
                        }
                    });
                }
            } catch (error) {
                updateStatus('Failed to start stream', 'error');
                console.error(error);
            }
        }

        async function renderQueue() {
            const queueContainer = document.getElementById('queue-list');
            const queueCountEl = document.getElementById('queue-count');
            const queue = await fetchQueue();

            queueCountEl.textContent = `${queue.length} track${queue.length !== 1 ? 's' : ''}`;

            if (queue.length === 0) {
                queueContainer.innerHTML = '<p class="queue-empty">Queue is empty. Add videos above to start!</p>';
                return;
            }

            queueContainer.innerHTML = queue.map((item, index) => {
                const isCurrentlyPlaying = currentQueueId === item.id;
                const positionBadge = `<span class="queue-position">${index + 1}</span>`;

                return `
                    <div class="queue-item ${isCurrentlyPlaying ? 'queue-item-playing' : ''}"
                         onclick="${isCurrentlyPlaying ? '' : `startStreamFromQueue('${item.youtube_id}', ${item.id})`}">
                        <div class="queue-info">
                            ${positionBadge}
                            <i class="fab fa-youtube"></i>
                            <span class="queue-title">${escapeHtml(item.title)}</span>
                            ${isCurrentlyPlaying ? '<i class="fas fa-volume-up queue-playing-icon"></i>' : ''}
                        </div>
                        <button onclick="event.stopPropagation(); removeFromQueue(${item.id})"
                                class="btn-remove-queue"
                                title="Remove from queue">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                `;
            }).join('');
        }

        // Auto-play next track when current track ends
        player.addEventListener('ended', async function () {
            console.log('Track ended, playing next...');
            await playNext();
        });

        // History Management
        async function fetchHistory() {
            try {
                const res = await fetch('/history');
                const data = await res.json();
                return data.history || [];
            } catch (e) {
                console.error('Error fetching history:', e);
                return [];
            }
        }

        async function clearHistory() {
            if (confirm('Are you sure you want to clear all history?')) {
                try {
                    await fetch('/history/clear', { method: 'POST' });
                    await renderHistory();
                } catch (e) {
                    console.error('Error clearing history:', e);
                }
            }
        }

        async function renderHistory() {
            const historyContainer = document.getElementById('history-list');
            const history = await fetchHistory();

            if (history.length === 0) {
                historyContainer.innerHTML = '<p class="history-empty">No history yet</p>';
                return;
            }

            historyContainer.innerHTML = history.map(item => {
                const timeAgo = getTimeAgo(item.last_played_at);
                const playCountBadge = item.play_count > 1 ? `<span class="play-count-badge">${item.play_count}Ã—</span>` : '';

                return `
                    <div class="history-item" onclick="loadFromHistory('${item.youtube_id}')">
                        <div class="history-info">
                            <i class="fab fa-youtube"></i>
                            <span class="history-title">${escapeHtml(item.title)}</span>
                        </div>
                        <div class="history-meta">
                            ${playCountBadge}
                            <span class="history-time">${timeAgo}</span>
                            <i class="fas fa-play-circle"></i>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function getTimeAgo(isoTimestamp) {
            const timestamp = new Date(isoTimestamp).getTime();
            const seconds = Math.floor((Date.now() - timestamp) / 1000);

            if (seconds < 60) return 'Just now';
            if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
            if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
            if (seconds < 604800) return `${Math.floor(seconds / 86400)}d ago`;
            return new Date(timestamp).toLocaleDateString();
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function loadFromHistory(videoId) {
            document.getElementById('youtube_video_id').value = videoId;
            startStream();
        }

        function extractVideoId(input) {
            // If it's already just an ID (11 characters, alphanumeric), return it
            if (/^[a-zA-Z0-9_-]{11}$/.test(input.trim())) {
                return input.trim();
            }

            // Try to extract from various YouTube URL formats
            const patterns = [
                /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})/,
                /youtube\.com\/watch\?.*v=([a-zA-Z0-9_-]{11})/
            ];

            for (const pattern of patterns) {
                const match = input.match(pattern);
                if (match) {
                    return match[1];
                }
            }

            // If no pattern matched, return the original input trimmed
            return input.trim();
        }

        async function startStream() {
            const input = document.getElementById('youtube_video_id').value;

            if (!input.trim()) {
                updateStatus('Please enter a YouTube ID or URL', 'error');
                return;
            }

            // Extract video ID from URL or use as-is if it's already an ID
            const youtube_video_id = extractVideoId(input);

            if (!youtube_video_id) {
                updateStatus('Invalid YouTube ID or URL', 'error');
                return;
            }

            // Get skip_transcription checkbox value (if it exists)
            const skipTranscriptionCheckbox = document.getElementById('skip_transcription');
            const skip_transcription = skipTranscriptionCheckbox ? skipTranscriptionCheckbox.checked : false;

            try {
                const res = await fetch('/stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ youtube_video_id, skip_transcription })
                });
                const data = await res.json();
                updateStatus(data.status || data.detail, res.ok ? 'streaming' : 'error');

                if (res.ok) {
                    isPlaying = true;
                    cancelRetry(); // Cancel any ongoing retries

                    // Re-render history to show the new entry
                    await renderHistory();

                    // Update browser window title with track name from history
                    const history = await fetchHistory();
                    const currentTrack = history.find(item => item.youtube_id === youtube_video_id);
                    if (currentTrack) {
                        updateWindowTitle(currentTrack.title);
                        setupMediaSession(currentTrack);
                    }

                    // Track current video for transcription (only if not skipped)
                    if (transcriptionEnabled) {
                        if (skip_transcription) {
                            currentVideoId = null;
                            // Update transcription status to show it was skipped
                            const container = document.getElementById('transcription-status');
                            if (container) {
                                container.innerHTML = '<p class="transcription-idle"><i class="fas fa-music"></i> Transcription skipped for this stream</p>';
                            }
                        } else {
                            currentVideoId = youtube_video_id;
                        }
                    }

                    // Reload audio to pick up new stream with cache-busting
                    const streamUrl = 'http://{{ host }}:{{ api_port }}/mystream?t=' + Date.now();
                    console.log('ðŸŽµ Setting audio player source to:', streamUrl);
                    player.src = streamUrl;
                    player.load();
                    player.play().catch(e => {
                        console.error('âŒ Audio playback failed:', e);
                        console.log('   Stream URL:', streamUrl);
                        // Auto-retry if initial play fails
                        if (isPlaying) {
                            retryStream();
                        }
                    });
                }
            } catch (error) {
                updateStatus('Failed to start stream', 'error');
                console.error(error);
            }
        }

        async function stopStream() {
            // Pause the player first
            player.pause();
            isPlaying = false;
            currentQueueId = null;

            // Cancel any retry attempts
            cancelRetry();

            // Reset browser window title
            updateWindowTitle(null);

            // Then call server to stop the stream
            try {
                const res = await fetch('/stop', { method: 'POST' });
                const data = await res.json();
                updateStatus(data.status || data.detail, 'idle');
            } catch (error) {
                updateStatus('Failed to stop stream', 'error');
                console.error(error);
            }

            // Update queue display
            await renderQueue();
        }

        function pauseAudio() {
            player.pause();
        }

        function playAudio() {
            player.play();
        }

        function rewind() {
            player.currentTime = Math.max(0, player.currentTime - 15);
        }

        function fastforward() {
            player.currentTime = Math.max(0, player.currentTime + 15);
        }

        function setSpeed(speed) {
            player.playbackRate = speed;

            // Update active button styling
            document.querySelectorAll('.btn-speed').forEach(btn => {
                btn.classList.remove('active');
            });

            const speedId = `speed-${speed}x`;
            const activeBtn = document.getElementById(speedId);
            if (activeBtn) {
                activeBtn.classList.add('active');
            }

            console.log(`Playback speed set to ${speed}x`);
        }

        async function updateStatus(message, state) {
            if (message) {
                statusText.innerText = 'Status: ' + message;
            }

            // Update status dot
            statusDot.className = 'status-dot';
            if (state === 'streaming') {
                statusDot.classList.add('streaming');
            } else if (state === 'error') {
                statusDot.classList.add('error');
            }
        }

        async function fetchStatus() {
            try {
                const res = await fetch('/status');
                const data = await res.json();
                updateStatus(data.status, data.status);
            } catch (error) {
                console.error('Failed to fetch status:', error);
            }
        }

        // Transcription functions
        async function fetchTranscriptionStatus() {
            if (!transcriptionEnabled || !currentVideoId) {
                return;
            }

            try {
                const res = await fetch(`/transcription/status/${currentVideoId}`);
                const data = await res.json();
                updateTranscriptionStatus(data);
            } catch (error) {
                console.error('Failed to fetch transcription status:', error);
            }
        }

        function updateTranscriptionStatus(data) {
            const container = document.getElementById('transcription-status');
            if (!container) return;

            const statusIcons = {
                'pending': '<i class="fas fa-clock"></i>',
                'checking_dedup': '<i class="fas fa-search"></i>',
                'transcribing': '<i class="fas fa-microphone"></i>',
                'summarizing': '<i class="fas fa-brain"></i>',
                'posting': '<i class="fas fa-upload"></i>',
                'completed': '<i class="fas fa-check-circle"></i>',
                'failed': '<i class="fas fa-exclamation-circle"></i>',
                'skipped': '<i class="fas fa-info-circle"></i>',
                'not_found': '<i class="fas fa-question-circle"></i>'
            };

            const statusLabels = {
                'pending': 'Waiting for audio download to complete...',
                'checking_dedup': 'Checking for existing note',
                'transcribing': 'Transcribing audio',
                'summarizing': 'Generating summary',
                'posting': 'Posting to Trilium',
                'completed': 'Completed',
                'failed': 'Failed',
                'skipped': 'Already exists in Trilium',
                'not_found': 'Not started'
            };

            const status = data.status || 'not_found';
            const icon = statusIcons[status] || '<i class="fas fa-circle"></i>';
            const label = statusLabels[status] || status;

            let html = `
                <div class="transcription-item">
                    <div class="transcription-info">
                        ${icon}
                        <span class="transcription-label">${label}</span>
                    </div>
            `;

            // Add action buttons based on status
            if (status === 'completed' || status === 'skipped') {
                html += `
                    <div class="transcription-actions">
                        <button onclick="viewSummary('${data.video_id}')" class="btn-transcription" title="View Summary">
                            <i class="fas fa-eye"></i>
                            <span>View Summary</span>
                        </button>
                `;

                if (data.trilium_note_url) {
                    html += `
                        <a href="${data.trilium_note_url}" target="_blank" class="btn-transcription" title="Open in Trilium">
                            <i class="fas fa-external-link-alt"></i>
                            <span>Open in Trilium</span>
                        </a>
                    `;
                }

                html += `</div>`;
            } else if (status === 'failed') {
                html += `
                    <div class="transcription-error">
                        <i class="fas fa-exclamation-triangle"></i>
                        <span>${data.error || 'Unknown error'}</span>
                    </div>
                `;
            } else if (status === 'pending' || status === 'transcribing' || status === 'summarizing' || status === 'posting' || status === 'checking_dedup') {
                html += `
                    <div class="transcription-progress">
                        <div class="spinner"></div>
                    </div>
                `;
            }

            html += `</div>`;
            container.innerHTML = html;
        }

        async function viewSummary(videoId) {
            const modal = document.getElementById('summary-modal');
            const content = document.getElementById('summary-content');

            modal.style.display = 'block';
            content.innerHTML = '<p>Loading summary...</p>';

            try {
                const res = await fetch(`/transcription/summary/${videoId}`);
                const data = await res.json();

                if (data.summary) {
                    // Format the summary with proper line breaks
                    const formattedSummary = data.summary.replace(/\n/g, '<br>');
                    content.innerHTML = `
                        <div class="summary-text">${formattedSummary}</div>
                        ${data.trilium_note_url ? `
                            <div class="summary-footer">
                                <a href="${data.trilium_note_url}" target="_blank" class="btn-transcription">
                                    <i class="fas fa-external-link-alt"></i>
                                    Open full note in Trilium
                                </a>
                            </div>
                        ` : ''}
                    `;
                } else {
                    content.innerHTML = '<p>Summary not available yet</p>';
                }
            } catch (error) {
                console.error('Failed to fetch summary:', error);
                content.innerHTML = '<p>Failed to load summary</p>';
            }
        }

        function closeSummaryModal() {
            const modal = document.getElementById('summary-modal');
            modal.style.display = 'none';
        }

        // Close modal when clicking outside
        window.onclick = function (event) {
            const modal = document.getElementById('summary-modal');
            if (event.target === modal) {
                closeSummaryModal();
            }
        }

        // Poll status every 3 seconds
        setInterval(fetchStatus, 3000);

        // Poll transcription status every 5 seconds
        if (transcriptionEnabled) {
            setInterval(fetchTranscriptionStatus, 5000);
        }

        // Initial status fetch, queue, and history render
        fetchStatus();
        renderQueue();
        renderHistory();
        if (transcriptionEnabled) {
            fetchTranscriptionStatus();
        }
    </script>
</body>

</html>